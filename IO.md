
# :memo: IO多路复用

<hr>

### epoll 对比 select：

https://blog.csdn.net/armlinuxww/article/details/92803381?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172039792716800215040029%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172039792716800215040029&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-92803381-null-null.142^v100^pc_search_result_base2&utm_term=epoll&spm=1018.2226.3001.4187

1. 性能优势:
    * O(1) 复杂度：epoll 的事件处理在常数时间内完成（O(1)），而 select 的复杂度为 O(n)，其中 n 是监听的文件描述符数量。随着文件描述符数量的增加，select 的性能会明显下降，而 epoll 则能保持稳定的性能。
    * 事件驱动：epoll 采用事件驱动模式，只在有事件发生时通知用户空间，而 select 采用轮询方式，每次调用都需要遍历所有的文件描述符，效率较低。

2. 更高的文件描述符限制:
    * 文件描述符数量：select 的文件描述符数量通常有上限（默认1024），受限于宏 FD_SETSIZE。而 epoll 没有这种限制，能够支持更大规模的并发连接。

3. 内存效率:
    * 内核与用户空间的交互：select 每次调用都需要将文件描述符集合从用户空间复制到内核空间，并返回结果，这会导致大量的内存复制开销。而 epoll 使用一个文件描述符将所有感兴趣的文件描述符信息传递给内核，并在内核中维护一个事件表，减少了内存复制的开销。

4. 更灵活的接口:
    * 边缘触发和水平触发：epoll 支持边缘触发（edge-triggered）和水平触发（level-triggered）两种模式，用户可以根据需求选择。而 select 只支持水平触发模式。
    * 文件描述符的添加和删除：epoll 提供了接口（epoll_ctl）可以动态地添加、修改和删除文件描述符，灵活性更高。而 select 每次调用都需要重新设置文件描述符集合。

5. 避免描述符集的重置:
    * 无需重置文件描述符集合：在使用 select 时，每次调用后都需要重置文件描述符集合，而 epoll 只需在文件描述符集合有变化时进行更新，减少了编程复杂度和开销。

6. 具体场景对比:
    * 使用 select：每次调用 select，服务器都需要遍历所有的文件描述符集合，以确定哪些描述符有事件发生，这在高并发场景下会产生明显的性能瓶颈。
    * 使用 epoll：服务器只需关注实际有事件发生的文件描述符，减少了遍历和不必要的检查，显著提升了性能。



